pragma solidity ^0.4.25;

contract CaCuocs{
    
    uint public amount = 0 ether;
    uint soNguoiSeQuayThuong = 2;
    struct Customer{
        uint price;
        address owner;
    }
    struct ownerToNumber{
        address owner;
    }
    Customer[] customers;
    ownerToNumber[] ownertonumbers;
    ownerToNumber[] ownertonumbers2;
    uint[] cacsodadcchon;
    
    mapping(address => uint) ownerToUserId;
    mapping(uint => address[]) numberToOwner;
    
    function randMod(uint _modulus) internal returns(uint) {
        return uint(keccak256(now, msg.sender, now % _modulus)) % _modulus;
    }
    
    function Reg() public{
        require(ownerToUserId[msg.sender]==0x0,"Bạn đã đăng ký rồi");
        uint8 id = uint8(customers.push(Customer(0, msg.sender)));
        ownerToUserId[msg.sender] = id;
    }
    function ChonSo(uint _number) public payable{
        require(ownerToUserId[msg.sender]!=0x0,"Bạn phải đăng ký trước");
        bool oke = true;
        for (uint8 i = 0; i < ownertonumbers.length; i++){
            if(ownertonumbers[i].owner == msg.sender){
                oke = false;
            }
        }
        require(oke==true,"Vui lòng đợi đến khi trao thưởng");
        ownertonumbers.push(ownerToNumber(msg.sender));
        require(msg.value >= 1 ether,"Tối thiểu 1 ether");
        amount +=msg.value;
        numberToOwner[_number].push(msg.sender);
        cacsodadcchon.push(_number);
        if(ownertonumbers.length%soNguoiSeQuayThuong==0){
            TraoThuong();
        }
    }
    
    function TraoThuong() private {
        uint rand = 1;
        address[] adr = numberToOwner[rand];
        if(adr.length>0){
            uint tienthuong = amount/adr.length;
            for (uint8 i = 0; i< adr.length; i++){
                for (uint8 i2 = 0; i2 < customers.length; i2++){
                    if(customers[i2].owner == adr[i]){
                        customers[i2].price +=tienthuong;
                    }
                }
            }
            for (uint8 i3 = 0; i3 < cacsodadcchon.length; i3++){
                delete numberToOwner[cacsodadcchon[i3]];
            }
            amount = 0 ether;
            delete cacsodadcchon;
            ownertonumbers = ownertonumbers2;
        }else{
            delete cacsodadcchon;
            ownertonumbers = ownertonumbers2;
        }
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}
